%%  Extract element from Jacobian matrix and construct equation string
%
%       Output
%           - Returns an equation string in Dynare notation
%
%       Input
%           - Filename of Matlab function that calculates residuals and
%             Jacobian matrix, which is automatically generated by Dynare
%             and called *_dynamic.m
%
%           - Element of Jacobian matrix that is requested, with the
%             following format:
%               d{%i}d{%s}{p,c,n}
%                   - %i:      integer indicating the equation number
%                   - %s:      string indicating the variable with respect
%                              to which the partial derivative is taken
%                   - {p,c,n}: character indicating the timing of the
%                              variable (previous, current, or next period)
%
%           - Dynare model information contained in M_, which includes the
%             names of the endogenous variables and the lead/lag incidence
%             matrix (among other things)
%
%       Joris de Wind (December 2016), email: jorisdewind@gmail.com
%==========================================================================

function equation = extract_element_jacobian(filename,element,M_)

% for models with no forward-looking variables, set partial derivatives
% with respect to next period variables to zero
if strcmp(element(end),'n') && size(M_.lead_lag_incidence,1) == 2,
    equation = ['# ',element,'=0;'];
    return
end

% extract all lines from file and put in cell array
fid = fopen(filename,'r');
lines = textscan(fid,'%s','delimiter','\n');
lines = lines{1};
fclose(fid);

% interpret which element of Jacobian matrix is requested
dindex = strfind(element,'d');
equation_number = str2double(element(dindex(1)+1:dindex(2)-1));	%eq number between d's
variable_number = get_endo_index(element(dindex(2)+1:end-1));   %var name after second d
period_number = strfind(['p','c','n'],element(end));            %timing of var at end
deriv_number = M_.lead_lag_incidence(period_number,variable_number); %deriv number
element_g1 = ['g1(',num2str(equation_number),',',num2str(deriv_number),')'];

% equation_number ==> row index Jacobian matrix
% deriv_number ==> column index Jacobian matrix

% find the right line and initialize equation string
try
    equation = lines{~cellfun('isempty',strfind(lines,element_g1))};
catch                                   %if element is missing in Jacobian matrix,
    equation = ['# ',element,'=0;'];    %partial derivative is simply zero
    return
end

% adjust equation string, left-hand side
equation = strrep(equation,element_g1,['# ',element]);

% adjust equation string, right-hand side
%   - endogenous variables
%   - exogenous variables
%   - parameters

% endogenous variables
for i = 1:nnz(M_.lead_lag_incidence),
    [iperiod,ivar] = find(M_.lead_lag_incidence == i);
    equation = strrep(equation,sprintf('y(%i)',i),...
        [strtrim(M_.endo_names(ivar,:)),sprintf('(%i)',iperiod-2)]);
end

% exogenous variables
equation = regexprep(equation,'x\(it_(.*?), (\d*?)\)', ...
    '${strtrim(M_.exo_names(str2num($2),:))}(${num2str(eval([$1,''+0'']))})');

% parameters
for i = 1:length(M_.params),
    equation = strrep(equation,sprintf('params(%i)',i),...
        strtrim(M_.param_names(i,:)));
end

end